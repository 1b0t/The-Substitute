// Generated by CoffeeScript 1.10.0
(function() {
  var cache, config, fanarttv, https, self, tmdb, trakt, utils;

  https = require('https');

  utils = require('../utils/utils');

  cache = require('../utils/cache');

  trakt = require('../external-services/trakt');

  fanarttv = require('../external-services/fanarttv');

  tmdb = require('../external-services/tmdb');

  config = require('../config.json');

  self = module.exports = {
    mediaType: {
      Movies: "movies",
      Shows: "shows"
    },
    fetchImageDataForTraktID: function(trakt_id, mediaType, callback, season_number, episode_number) {
      var error, finalize, pendingRequests, processResponseFromFanartTV, processResponseFromTMDB, processResponseFromTrakt, result, success, traktIDs;
      if (season_number == null) {
        season_number = null;
      }
      if (episode_number == null) {
        episode_number = null;
      }
      traktIDs = null;
      pendingRequests = 0;
      result = {};
      success = function(json) {
        result.reference_id = trakt_id;
        result.ids = traktIDs;
        result.success = true;
        if (json.service === "tmdb") {
          result.tmdb = json;
        }
        if (json.service === "fanarttv") {
          result.fanarttv = json;
        }
        return finalize();
      };
      error = function(err, genericMessage) {
        result.errors = [];
        if (err != null) {
          err.reference_id = trakt_id;
          result.errors.push(err);
        } else {
          genericMessage.reference_id = trakt_id;
          result.errors.push(genericMessage);
        }
        return finalize();
      };
      finalize = function() {
        pendingRequests = pendingRequests - 1;
        if (pendingRequests <= 0) {
          if (season_number != null) {
            result.season = season_number;
          }
          if (episode_number != null) {
            result.episode = episode_number;
          }
          result.reference_id = trakt_id;
          if ((config.merge_assets != null) && config.merge_assets === true) {
            utils.merge(result);
          }
          return callback(result);
        }
      };
      processResponseFromTrakt = function(json, err) {
        var id;
        if (json != null) {
          pendingRequests = pendingRequests - 1;
          traktIDs = json["ids"];
          console.log(JSON.stringify(traktIDs, null, 4));
          if (traktIDs != null) {
            if (config.tmdb.enabled) {
              id = json["ids"]["tmdb"];
              if (id != null) {
                pendingRequests = pendingRequests + 1;
                switch (mediaType) {
                  case self.mediaType.Movies:
                    tmdb.fetchImageMetaData(tmdb.mediaType.Movie, id, processResponseFromTMDB);
                    break;
                  case self.mediaType.Shows:
                    tmdb.fetchImageMetaData(tmdb.mediaType.Show, id, processResponseFromTMDB, season_number, episode_number);
                }
              } else {
                error(null, {
                  success: false,
                  message: "tmdb id not defined"
                });
              }
            }
            if (config.fanarttv.enabled) {
              pendingRequests = pendingRequests + 1;
              switch (mediaType) {
                case self.mediaType.Movies:
                  id = json["ids"]["imdb"];
                  if (id != null) {
                    fanarttv.fetchImageMetaData(fanarttv.mediaType.Movie, id, processResponseFromFanartTV);
                  } else {
                    error(null, {
                      success: false,
                      message: "imdb id not defined"
                    });
                  }
                  break;
                case self.mediaType.Shows:
                  id = json["ids"]["tvdb"];
                  if (id != null) {
                    fanarttv.fetchImageMetaData(fanarttv.mediaType.Show, id, processResponseFromFanartTV, season_number, episode_number);
                  } else {
                    error(null, {
                      success: false,
                      message: "tvdb id not defined"
                    });
                  }
              }
            }
            if (config.fanarttv.enabled === false && config.tmdb.enabled === false) {
              return error(null, {
                success: false,
                message: "no third party image services enabled in config.json"
              });
            }
          } else {
            return error(null, {
              success: false,
              service: "trakt",
              message: "failed to get ids from trakt"
            });
          }
        } else {
          return error(err, {
            success: false,
            service: "trakt",
            message: "failed to load data from trakt"
          });
        }
      };
      processResponseFromFanartTV = function(json, err) {
        if (json != null) {
          return success(json);
        } else {
          return error(err, {
            success: false,
            service: "fanarttv",
            message: "failed to load data from fanarttv"
          });
        }
      };
      processResponseFromTMDB = function(json, err) {
        if (json != null) {
          return success(json);
        } else {
          return error(err, {
            success: false,
            service: "tmdb",
            message: "failed to load data from tmdb"
          });
        }
      };
      pendingRequests = pendingRequests + 1;
      switch (mediaType) {
        case self.mediaType.Movies:
          return trakt.fetchIDs(trakt.mediaType.Movie, trakt_id, processResponseFromTrakt);
        case self.mediaType.Shows:
          return trakt.fetchIDs(trakt.mediaType.Show, trakt_id, processResponseFromTrakt);
        default:
          return error(null, {
            status: false,
            message: "mediaType not supported"
          });
      }
    },
    get: function(req, res, next, mediaType) {
      var episode_number, season_number, trakt_id;
      trakt_id = req.params.trakt_id;
      season_number = req.params.season_number;
      episode_number = req.params.episode_number;
      if (trakt_id != null) {
        self.fetchImageDataForTraktID(trakt_id, mediaType, function(json) {
          res.send(json);
          return next();
        }, season_number, episode_number);
      } else {
        res.send({
          success: false,
          message: "required parameter :trakt_id missing"
        });
        next();
      }
    },
    getMultiple: function(req, res, next, mediaType) {
      var fetchImageDataForTraktIDs, traktIDs;
      fetchImageDataForTraktIDs = function(ids, callback) {
        var fetchedDataForMedia, i, id, len, pendingRequests, result, results;
        pendingRequests = ids.length;
        result = [];
        fetchedDataForMedia = function(json) {
          pendingRequests -= 1;
          result.push(json);
          if (pendingRequests === 0) {
            cache.save(req.params[mediaType], JSON.stringify(result));
            return callback(result);
          }
        };
        results = [];
        for (i = 0, len = traktIDs.length; i < len; i++) {
          id = traktIDs[i];
          results.push(self.fetchImageDataForTraktID(id, mediaType, fetchedDataForMedia));
        }
        return results;
      };
      if (req.params[mediaType] != null) {
        traktIDs = req.params[mediaType].split(',');
        if (traktIDs.length > 0 && req.params[mediaType].length > 0) {
          return cache.load("?movies=" + req.params[mediaType], function(cachedData) {
            var json;
            if (cachedData != null) {
              json = JSON.parse(cachedData);
              if (json != null) {
                res.send(json);
                next();
                return;
              }
            }
            return fetchImageDataForTraktIDs(traktIDs, function(json) {
              res.send({
                success: true,
                data: json
              });
              return next();
            });
          });
        } else {
          res.status(400);
          res.send({
            success: false,
            message: "comma seperated list of movie_ids or slugs named 'movies' is required"
          });
          return next();
        }
      } else {
        res.status(400);
        res.send({
          success: false
        });
        return next();
      }
    }
  };

}).call(this);
